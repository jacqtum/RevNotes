<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Segoe UI" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (en-US, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Segoe UI;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="408"/>

<div>
<span><div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;">SQL Commands</font></div><ul><li><div><font style="font-size: 10pt;"><b>Data Definition Language (DDL) -</b> These SQL commands are used for creating, modifying, and dropping the structure of database objects. The commands are CREATE, ALTER, DROP, RENAME, and TRUNCATE.</font></div></li><li><div><font style="font-size: 10pt;"> <b>Data Manipulation Language (DML) -</b> These SQL commands are used for storing, retrieving, modifying, and deleting data.</font></div></li><ul><li><div><font style="font-size: 10pt;">These Data Manipulation Language commands are: SELECT, INSERT, UPDATE, and DELETE.</font></div></li></ul><li><div><font style="font-size: 10pt;"> <b>Transaction Control Language (TCL) -</b> These SQL commands are used for managing changes affecting the data. These commands are COMMIT, ROLLBACK, and SAVEPOINT.</font></div></li></ul><ul><li><div><font style="font-size: 10pt;"><b>Data Control Language (DCL) -</b> These SQL commands are used for providing security to database objects. These commands are GRANT and REVOKE.</font></div></li><li><div><font style="font-size: 10pt;">Select</font></div></li><ul><li><div><span style="color: rgb(51, 51, 51); font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;">The most commonly used SQL command is SELECT statement. SQL SELECT statement is used to query or retrieve data from a table in the database. A query may retrieve information from specified columns or from all of the columns in the table. To create a simple SQL SELECT Statement, you must specify the column(s) name and the table name. The whole query is called SQL SELECT Statement.</font></span></div></li><ul><li><div><span style="color: rgb(51, 51, 51);"><font style="font-size: 10pt;">SELECT column_list FROM table-name</font></span></div></li><li><div><span style="color: rgb(51, 51, 51);"><font style="font-size: 10pt;">[WHERE Clause]</font></span></div></li><li><div><span style="color: rgb(51, 51, 51);"><font style="font-size: 10pt;">[GROUP BY clause]</font></span></div></li><li><div><span style="color: rgb(51, 51, 51);"><font style="font-size: 10pt;">[HAVING clause]</font></span></div></li><li><div><span style="color: rgb(51, 51, 51);"><font style="font-size: 10pt;">[ORDER BY clause];</font></span></div></li></ul></ul><li><div><font style="font-size: 10pt;">SQL Alias</font></div></li><ul><li><div><font style="font-size: 10pt;">SQL Aliases are defined for columns and tables. Basically aliases is created to make the column selected more readable.</font></div></li><ul><li><div><font style="font-size: 10pt;">SELECT first_name AS Name FROM student_details;</font></div></li><li><div><font style="font-size: 10pt;">or</font></div></li><li><div><font style="font-size: 10pt;">SELECT first_name Name FROM student_details;</font></div></li></ul></ul><li><div><font style="font-size: 10pt;">Where</font></div></li><ul><li><div><font style="font-size: 10pt;">SQL WHERE Clause</font></div></li><li><div><font style="font-size: 10pt;">The WHERE Clause is used when you want to retrieve specific information from a table excluding other irrelevant data. For example, when you want to see the information about students in class 10th only then you do need the information about the students in other class. Retrieving information about all the students would increase the processing time for the query.</font></div></li></ul></ul><ul><ul><li><div><font style="font-size: 10pt;">So SQL offers a feature called WHERE clause, which we can use to restrict the data that is retrieved. The condition you provide in the WHERE clause filters the rows retrieved from the table and gives you only those rows which you expected to see. WHERE clause can be used along with SELECT, DELETE, UPDATE statements.</font></div></li><ul><li><div><font style="font-size: 10pt;">SELECT first_name, last_name FROM student_details</font></div></li><li><div><font style="font-size: 10pt;">WHERE id = 100;</font></div></li></ul></ul><li><div><font style="font-size: 10pt;">SQL Operators</font></div></li><ul><li><div><font style="font-size: 10pt;">= Equals to</font></div></li><li><div><font style="font-size: 10pt;">&lt;&gt; != Is not equal to</font></div></li><li><div><font style="font-size: 10pt;">&lt; Less than</font></div></li><li><div><font style="font-size: 10pt;">&gt; Greater than</font></div></li><li><div><font style="font-size: 10pt;">&gt;= greater than or equal to</font></div></li><li><div><font style="font-size: 10pt;">&lt;= less than or equal to</font></div></li></ul><li><div><font style="font-size: 10pt;">Logicial Operators</font></div></li><ul><li><div><font style="font-size: 10pt;">There are three Logical Operators namely, AND, OR, and NOT. These operators compare two conditions at a time to determine whether a row can be selected for the output. When retrieving data using a SELECT statement, you can use logical operators in the WHERE clause, which allows you to combine more than one condition.</font></div></li><li><div><font style="font-size: 10pt;">OR</font></div></li><ul><li><div><font style="font-size: 10pt;">For the row to be selected at least one of the conditions must be true</font></div></li><li><div><font style="font-size: 10pt;">SELECT first_name, last_name, subject</font></div></li><li><div><font style="font-size: 10pt;">FROM student_details</font></div></li><li><div><font style="font-size: 10pt;">WHERE subject = 'Maths' OR subject = 'Science'</font></div></li></ul><li><div><font style="font-size: 10pt;">AND</font></div></li><ul><li><div><font style="font-size: 10pt;">For a row to be select all the specified conditions must be selected to be true</font></div></li><li><div><font style="font-size: 10pt;">SELECT first_name, last_name, age</font></div></li><li><div><font style="font-size: 10pt;">FROM student_details</font></div></li><li><div><font style="font-size: 10pt;">WHERE age &gt;= 10 AND age &lt;= 15;</font></div></li></ul><li><div><font style="font-size: 10pt;">NOT</font></div></li><ul><li><div><font style="font-size: 10pt;">For a row to be selected the specified condition must be false</font></div></li><li><div><font style="font-size: 10pt;">SELECT first_name, last_name, games</font></div></li><li><div><font style="font-size: 10pt;">FROM student_details</font></div></li><li><div><font style="font-size: 10pt;">WHERE NOT games = 'Football'</font></div></li></ul></ul><li><div><font style="font-size: 10pt;">SQL Comparison Keywords</font></div></li><ul><li><div><span style="color: rgb(51, 51, 51); font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 10pt;">There are other comparison keywords available in sql which are used to enhance the search capabilities of a sql query. They are &quot;IN&quot;, &quot;BETWEEN...AND&quot;, &quot;IS NULL&quot;, &quot;LIKE&quot;.</font></span></div></li><li><div><span style="color: rgb(51, 51, 51);">Like</span></div></li><li><div><span style="color: rgb(51, 51, 51);"><span style="color: rgb(51, 51, 51);">The LIKE operator is used to list all rows in a table whose column values match a specified pattern. It is useful when you want to search rows to match a specific pattern, or when you do not know the entire value. For this purpose we use a wildcard character '%'.</span></span></div></li><ul><li><div>SELECT first_name, last_name</div></li><li><div>FROM student_details</div></li><li><div>WHERE first_name LIKE 'S%';</div></li></ul><li><div><span style="color: rgb(51, 51, 51);">There is another wildcard character you can use with LIKE operator. It is the underscore character, ' _ ' . In a search string, the underscore signifies a single character.</span></div></li><ul><li><div>SELECT first_name, last_name</div></li><li><div>FROM student_details</div></li><li><div>WHERE first_name LIKE '_a%';</div></li></ul></ul><li><div>Between...And</div></li><ul><li><div>The operator BETWEEN and AND, are used to compare data for a range of values.</div></li><ul><li><div>SELECT first_name, last_name, age</div></li><li><div>FROM student_details</div></li><li><div>WHERE age BETWEEN 10 AND 15;</div></li></ul></ul><li><div>In</div></li><ul><li><div>The IN operator is used when you want to compare a column with more than one value. It is similar to an OR condition.</div></li><ul><li><div>SELECT first_name, last_name, subject</div></li><li><div>FROM student_details</div></li><li><div>WHERE subject IN ('Maths', 'Science');</div></li></ul></ul><li><div>Is Null</div></li><ul><li><div>A column value is NULL if it does not exist. The IS NULL operator is used to display all the rows for columns that do not have a value.</div></li><ul><li><div>SELECT first_name, last_name</div></li><li><div>FROM student_details</div></li><li><div>WHERE games IS NULL</div></li></ul></ul><li><div>Not In</div></li><ul><li><div>The NOT IN operator is used when you want to retrieve a column that has no entries in the table or referencing table.</div></li></ul></ul><ul><li><div>This is important for keywords when we want to find records to management questions such as:</div></li></ul><ul><li><div>Which customer has not done any transaction with us?</div></li></ul><ul><ul><li><div>Which product is not selling in the past few days?</div></li><ul><li><div>Select first_name, last_name, cust_id from customer where cust_id NOT IN ( Select cust_id from transactions)</div></li></ul></ul><li><div>Order By</div></li><ul><li><div>The ORDER BY clause is used in a SELECT statement to sort results either in ascending or descending order. Oracle sorts query results in ascending order by default.</div></li><ul><li><div>SELECT column-list</div></li><li><div>FROM table_name [WHERE condition]</div></li><li><div>[ORDER BY column1 [, column2, .. columnN] [DESC]];</div></li></ul></ul></ul><ul><li><div>SQL Insert</div></li><ul><li><div>The INSERT Statement is used to add new rows of data to a table.</div></li><li><div>While inserting a row, if you are adding value for all the columns of the table you need not specify the column(s) name in the sql query. But you need to make sure the order of the values is in the same order as the columns in the table. The sql insert query will be as follows</div></li><ul><li><div>INSERT INTO TABLE_NAME</div></li><li><div>VALUES (value1, value2, value3,...valueN);</div></li></ul></ul><li><div>SQL Update</div></li><ul><li><div>The UPDATE Statement is used to modify the existing rows in a table.</div></li><ul><li><div>UPDATE employee</div></li><li><div>SET location ='Mysore'</div></li><li><div>WHERE id = 101;</div></li></ul></ul><li><div>SQL Delete</div></li><ul><li><div>The DELETE Statement is used to delete rows from a table.</div></li><li><div>DELETE FROM table_name [WHERE condition];</div></li></ul><li><div>SQL Truncate</div></li><ul><li><div>To delete all the rows from employee table, the query would be like,</div></li><ul><li><div>TRUNCATE TABLE employee;</div></li></ul></ul><li><div>SQL Drop</div></li><ul><li><div>The SQL DROP command is used to remove an object from the database. If you drop a table, all the rows in the table is deleted and the table structure is removed from the database. Once a table is dropped we cannot get it back, so be careful while using DROP command. When a table is dropped all the references to the table will not be valid.</div></li><ul><li><div>DROP TABLE table_name;</div></li></ul></ul><li><div>SQL Create Database</div></li><ul><li><div>The CREATE DATABASE Statement is used to create a database. After creating a database, we can create several other database objects (tables, views, procedures etc.) into it. The user should have admin privileges for creating database.:</div></li><ul><li><div>CREATE DATABASE database_name</div></li></ul></ul><li><div>SQL Use Database</div></li><ul><li><div>The USE Statement is used to select a database and perform SQL operations into that database.</div></li></ul></ul><ul><ul><li><div>The database remains default until end of session or execution of another USE statement with some other database.</div></li><ul><li><div>USE DATABASE database_name</div></li></ul></ul><li><div>SQL Alter Database</div></li><ul><li><div>The ALTER DATABASE Statement is used to change characteristics of a database.</div></li></ul></ul><ul><ul><li><div>After creating a database, we can change its properties by executing ALTER DATABASE statement. The user should have admin privileges for modifying a database.</div></li><ul><li><div>ALTER DATABASE database_name</div></li></ul></ul><li><div>SQL Drop Database</div></li><ul><li><div>The DROP DATABASE Statement is used to drop or delete a database. Dropping of the database will drop all database objects (tables, views, procedures etc.) inside it. The user should have admin privileges for deleting a database.</div></li><li><div>Can not be rolled back</div></li><ul><li><div>DROP DATABASE database_name;</div></li></ul></ul><li><div>SQL Primary Key</div></li><ul><li><div>This constraint defines a column or combination of columns which uniquely identifies each row in the table.</div></li><li><div>Column Level</div></li><ul><li><div>CREATE TABLE employee</div></li><li><div>( id number(5) PRIMARY KEY,</div></li><li><div>name char(20),</div></li><li><div>dept char(10),</div></li><li><div>age number(2),</div></li><li><div>salary number(10),</div></li><li><div>location char(10)</div></li></ul><li><div>Bottom of table creation</div></li><ul><li><div>CREATE TABLE employee</div></li><li><div>( id number(5),</div></li><li><div>name char(20),</div></li><li><div>dept char(10),</div></li><li><div>age number(2),</div></li><li><div>salary number(10),</div></li><li><div>location char(10),</div></li><li><div>CONSTRAINT emp_id_pk PRIMARY KEY (id)</div></li><li><div>);</div></li></ul><li><div>Table level</div></li><ul><li><div>CREATE TABLE employee</div></li><li><div>( id number(5), NOT NULL,</div></li><li><div>name char(20),</div></li><li><div>dept char(10),</div></li><li><div>age number(2),</div></li><li><div>salary number(10),</div></li><li><div>location char(10),</div></li><li><div>ALTER TABLE employee ADD CONSTRAINT PK_EMPLOYEE_ID PRIMARY KEY (id)</div></li><li><div>);</div></li></ul><li><div>SQL Foreign Key</div></li><ul><li><div>This constraint identifies any column referencing the PRIMARY KEY in another table. It establishes a relationship between two columns in the same table or between different tables. For a column to be defined as a Foreign Key, it should be a defined as a Primary Key in the table which it is referring. One or more columns can be defined as Foreign key.</div></li><li><div>Lets use the &quot;product&quot; table and &quot;order_items&quot;.</div></li><li>Column Level</li><ul><li><div>CREATE TABLE product</div></li><li><div>( product_id number(5) CONSTRAINT pd_id_pk PRIMARY KEY,</div></li><li><div>product_name char(20),</div></li><li><div>supplier_name char(20),</div></li><li><div>unit_price number(10)</div></li><li><div>);</div></li><li><div><br/></div></li><li><div>CREATE TABLE order_items</div></li><li><div>( order_id number(5) CONSTRAINT od_id_pk PRIMARY KEY,</div></li><li><div>product_id number(5) CONSTRAINT pd_id_fk REFERENCES, product(product_id),</div></li><li><div>product_name char(20),</div></li><li><div>supplier_name char(20),</div></li><li><div>unit_price number(10)</div></li><li><div>);</div></li></ul><li><div>Table Level</div></li><ul><li><div>CREATE TABLE order_items</div></li><li><div>( order_id number(5) ,</div></li><li><div>product_id number(5),</div></li><li><div>product_name char(20),</div></li><li><div>supplier_name char(20),</div></li><li><div>unit_price number(10)</div></li><li><div>CONSTRAINT od_id_pk PRIMARY KEY(order_id),</div></li><li><div>CONSTRAINT pd_id_fk FOREIGN KEY(product_id) REFERENCES product(product_id)</div></li><li><div>);</div></li></ul></ul><li><div>SQL Not Null</div></li><ul><li><div>This constraint ensures all rows in the table contain a definite value for the column which is specified as not null. Which means a null value is not allowed.</div></li><ul><li><div>CREATE TABLE employee</div></li><li><div>( id number(5),</div></li><li><div>name char(20) CONSTRAINT nm_nn NOT NULL,</div></li><li><div>dept char(10),</div></li><li><div>age number(2),</div></li><li><div>salary number(10),</div></li><li><div>location char(10)</div></li><li><div>);</div></li></ul></ul><li><div>SQL Unique Key</div></li><ul><li><div>This constraint ensures that a column or a group of columns in each row have a distinct value. A column(s) can have a null value but the values cannot be duplicated.</div></li><li><div>Column Table</div></li><ul><li><div>CREATE TABLE employee</div></li><li><div>( id number(5) PRIMARY KEY,</div></li><li><div>name char(20),</div></li><li><div>dept char(10),</div></li><li><div>age number(2),</div></li><li><div>salary number(10),</div></li><li><div>location char(10) UNIQUE</div></li><li><div>);</div></li></ul><li><div>Table Level</div></li><ul><li><div>CREATE TABLE employee</div></li><li><div>( id number(5) PRIMARY KEY,</div></li><li><div>name char(20),</div></li><li><div>dept char(10),</div></li><li><div>age number(2),</div></li><li><div>salary number(10),</div></li><li><div>location char(10),</div></li><li><div>CONSTRAINT loc_un UNIQUE(location)</div></li><li><div>);</div></li></ul></ul><li><div>SQL Check Constraint</div></li><ul><li><div>This constraint defines a business rule on a column. All the rows must satisfy this rule. The constraint can be applied for a single column or a group of columns.</div></li><li><div>Column Table</div></li><ul><li><div>CREATE TABLE employee</div></li><li><div>( id number(5) PRIMARY KEY,</div></li><li><div>name char(20),</div></li><li><div>dept char(10),</div></li><li><div>age number(2),</div></li><li><div>gender char(1) CHECK (gender in ('M','F')),</div></li><li><div>salary number(10),</div></li><li><div>location char(10)</div></li><li><div>);</div></li></ul><li><div>Table Level</div></li><ul><li><div>CREATE TABLE employee</div></li><li><div>( id number(5) PRIMARY KEY,</div></li><li><div>name char(20),</div></li><li><div>dept char(10),</div></li><li><div>age number(2),</div></li><li><div>gender char(1),</div></li><li><div>salary number(10),</div></li><li><div>location char(10),</div></li><li><div>CONSTRAINT gender_ck CHECK (gender in ('M','F'))</div></li><li><div>);</div></li></ul></ul><li><div>Auto Increment</div></li><ul><li><div>AUTO INCREMENT fields are used for auto generating values for particular column whenever new row is being inserted.</div></li></ul></ul></ul><ul><ul><li><div>Very often the primary key of a table needs to be created automatically; we define that field as AUTO INCREMENT field.</div></li></ul><li><div>SQL Joins</div></li><ul><li><div>SQL Joins are used to relate information in different tables. A Join condition is a part of the sql query that retrieves rows from two or more tables. A SQL Join condition is used in the SQL WHERE Clause of select, update, delete statements.</div></li><li><div>INNER JOIN</div></li><ul><li><div>Returns records that have matching values in both tables. Returns records that have matching values in both tables</div></li><li><div>The following SQL statement selects all orders with customer information:</div></li><li><div>Two Tables:</div></li><ul><li><div>SELECT Orders.OrderID, Customers.CustomerName</div></li><li><div>FROM Orders</div></li><li><div>INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;</div></li></ul><li><div>Three Tables</div></li><ul><li><div>SELECT Orders.OrderID, Customers.CustomerName, Shippers.ShipperName</div></li><li><div>FROM ((Orders</div></li><li><div>INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID)</div></li><li><div>INNER JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID);</div></li></ul></ul><li><div>LEFT JOIN</div></li><ul><li><div>Return all records from the left table, and the matched records from the right table.</div></li><li><div>The following SQL statement will select all customers, and any orders they might have:</div></li><li><div>Two Tables:</div></li><ul><li><div>SELECT Customers.CustomerName, Orders.OrderID</div></li><li><div>FROM Customers</div></li><li><div>LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID</div></li><li><div>ORDER BY Customers.CustomerName;</div></li></ul></ul><li><div>RIGHT JOIN</div></li><ul><li><div>Return all records from the right table, and the matched records from the left table</div></li><li><div>The following SQL statement will return all employees, and any orders they might have placed:</div></li><li><div>Two Tables:</div></li><ul><li><div>SELECT Orders.OrderID, Employees.LastName, Employees.FirstName</div></li><li><div>FROM Orders</div></li><li><div>RIGHT JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID</div></li><li><div>ORDER BY Orders.OrderID;</div></li></ul></ul><li><div>FULL JOIN</div></li><ul><li><div>Return all records when there is a match in either left or right table</div></li><li><div>FULL OUTER JOIN can potentially return very large result-sets!</div></li><ul><li><div>SELECT Customers.CustomerName, Orders.OrderID</div></li><li><div>FROM Customers</div></li><li><div>FULL OUTER JOIN Orders ON Customers.CustomerID=Orders.CustomerID</div></li><li><div>ORDER BY Customers.CustomerName;</div></li></ul></ul><li><div>CROSS JOIN</div></li><ul><li><div>The SQL CROSS JOIN produces a result set which is the number of rows in the first table multiplied by the number of rows in the second table if no WHERE clause is used along with CROSS JOIN.This kind of result is called as Cartesian Product.</div></li></ul></ul></ul><ul><li><div>If WHERE clause is used with CROSS JOIN, it functions like an INNER JOIN.</div></li></ul><ul><ul><ul><li><div>An alternative way of achieving the same result is to use column names separated by commas after SELECT and mentioning the table names involved, after a FROM clause.</div></li><ul><li><div>SELECT *</div></li><li><div>FROM table1</div></li><li><div>CROSS JOIN table2;</div></li></ul></ul><li><div>SELF JOIN</div></li><ul><li><div>A self JOIN is a regular join, but the table is joined with itself.</div></li><ul><li><div>SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City</div></li><li><div>FROM Customers A, Customers B</div></li><li><div>WHERE A.CustomerID &lt;&gt; B.CustomerID</div></li><li><div>AND A.City = B.City</div></li><li><div>ORDER BY A.City;</div></li></ul></ul></ul><li><div>SQL Views</div></li><ul><li><div>A VIEW is a virtual table, through which a selective portion of the data from one or more tables can be seen. Views do not contain data of their own. They are used to restrict access to the database or to hide data complexity. A view is stored as a SELECT statement in the database. DML operations on a view like INSERT, UPDATE, DELETE affects the data in the original table upon which the view is based.</div></li><ul><li><div>CREATE VIEW view_product</div></li><li><div>AS</div></li><li><div>SELECT product_id, product_name</div></li><li><div>FROM product;</div></li></ul></ul><li><div>UNION ALL/UNION</div></li><ul><li><div>The SQL UNION ALL operator is used to combine the result sets of 2 or more SELECT statements. It does not remove duplicate rows between the various SELECT statements (all rows are returned).</div></li></ul></ul><ul><ul><li><div>Each SELECT statement within the UNION ALL must have the same number of fields in the result sets with similar data types.</div></li><li><div>UNION removes duplicate rows.</div></li><li><div>UNION ALL does not remove duplicate rows.</div></li></ul><li><div>INTERSECT</div></li><ul><li><div>The INTERSECT query will return the records between two tables. These are the records that exist in both Dataset1 and Dataset2.</div></li></ul></ul><ul><li><div>Each SQL statement within the SQL INTERSECT must have the same number of fields in the result sets with similar data types.</div></li><li><div>In this INTERSECT example, the query will return the records from the contacts table where the contact_id, last_name, and first_name values match the customer_id, last_name, and first_name value from the customers table.</div></li></ul><ul><ul><li><div>There are WHERE conditions on each data set to further filter the results so that only records from the contacts are returned where the last_name is not Anderson. The records from the customers table are returned where the customer_id is less than 50</div></li><ul><li>SELECT contact_id, last_name, first_name</li><li><div>FROM contacts</div></li><li><div>WHERE last_name &lt;&gt; 'Anderson'</div></li><li><div>INTERSECT</div></li><li><div>SELECT customer_id, last_name, first_name</div></li><li><div>FROM customers</div></li><li><div>WHERE customer_id &lt; 50;</div></li></ul></ul><li><div>MINUS</div></li><ul><li><div>The SQL MINUS operator is used to return all rows in the first SELECT statement that are not returned by the second SELECT statement. Each SELECT statement will define a dataset. The MINUS operator will retrieve all records from the first dataset and then remove from the results all records from the second dataset.</div></li><ul><li><div>SELECT supplier_id</div></li><li><div>FROM suppliers</div></li><li><div>MINUS</div></li><li><div>SELECT supplier_id</div></li><li><div>FROM orders;</div></li></ul><li><div>This SQL MINUS example returns all supplier_id values that are in the suppliers table and not in the orders table. What this means is that if a supplier_id value existed in the suppliers table and also existed in the orders table, the supplier_id value would not appear in this result set.</div></li></ul><li><div>Scalar</div></li><ul><li><div>First()</div></li><ul><li><div>The FIRST() function returns the first value of the selected column.</div></li><li><div>SELECT FIRST(column_name) FROM table_name;</div></li></ul><li><div>Last()</div></li><ul><li><div>The LAST() function returns the last value of the selected column. It can be used only in MS ACCESS.</div></li><li><div>SELECT LAST(column_name) FROM table_name;</div></li></ul><li><div>UCASE()</div></li><ul><li><div>It converts the value of a field to uppercase.</div></li><li><div>SELECT UCASE(column_name) FROM table_name;</div></li></ul><li><div>LCASE()</div></li><ul><li><div>SELECT LCASE(column_name) FROM table_name;</div></li></ul><li><div>MD()</div></li><ul><li><div>The MID() function extracts texts from the text field.</div></li><li><div>SELECT MID(column_name,start,length) AS some_name FROM table_name;</div></li></ul><li><div>LEN()</div></li><ul><li><div>The LEN() function returns the length of the value in a text field.</div></li><li><div>SELECT LENGTH(column_name) FROM table_name;</div></li></ul><li><div>ROUND()</div></li><ul><li><div>The ROUND() function is used to round a numeric field to the number of decimals specified.NOTE: Many database systems have adopted the IEEE 754 standard for arithmetic operations, which says that when any numeric .5 is rounded it results to the nearest even integer i.e, 5.5 and 6.5 both gets rounded off to 6.</div></li><li><div>SELECT ROUND(column_name,decimals) FROM table_name;</div></li></ul><li><div>NOW()</div></li><ul><li><div>The NOW() function returns the current system date and time.</div></li><li><div>SELECT NOW() FROM table_name;</div></li></ul><li><div>FORMAT()</div></li><ul><li><div>The FORMAT() function is used to format how a field is to be displayed.</div></li><li><div>SELECT FORMAT(column_name,format) FROM table_name;</div></li></ul></ul><li><div>Group Functions</div></li><ul><li><div>Group functions are built-in SQL functions that operate on groups of rows and return one value for the entire group. These functions are: COUNT, MAX, MIN, AVG, SUM, DISTINCT</div></li><li><div>SQL Count()</div></li><ul><li><div>This function returns the number of rows in the table that satisfies the condition specified in the WHERE condition. If the WHERE condition is not specified, then the query returns the total number of rows in the table.</div></li><ul><li><div>SELECT COUNT (*) FROM employee</div></li></ul><li><div>WHERE dept = 'Electronics';</div></li></ul><li><div>SQL Distinct()</div></li><ul><li><div>This function is used to select the distinct rows.</div></li><li><div>To get the count of employees with unique name, the query would be:</div></li><ul><li><div>SELECT COUNT (DISTINCT name) FROM employee;</div></li></ul></ul><li><div>SQL Max()</div></li><ul><li><div>This function is used to get the maximum value from a column.</div></li><ul><li><div>SELECT MAX (salary) FROM employee;</div></li></ul></ul><li><div>SQL Min()</div></li><ul><li><div>This function is used to get the minimum value from a column.</div></li><ul><li><div>SELECT MIN (salary) FROM employee;</div></li></ul></ul><li><div>SQL Avg()</div></li><ul><li><div>This function is used to get the average value of a numeric column.</div></li><ul><li><div>SELECT AVG (salary) FROM employee;</div></li></ul></ul><li><div>SQL Sum()</div></li><ul><li><div>This function is used to get the sum of a numeric column</div></li><ul><li><div>SELECT SUM (salary) FROM employee;</div></li></ul></ul></ul><li><div>Group By</div></li><ul><li><div>The SQL GROUP BY Clause is used along with the group functions to retrieve data grouped according to one or more columns.</div></li><li><div>If you want to know the total amount of salary spent on each department, the query would be:</div></li><ul><li><div>SELECT dept, SUM (salary)</div></li><li><div>FROM employee</div></li><li><div>GROUP BY dept;</div></li></ul><li><div>The group by clause should contain all the columns in the select list expect those used along with the group functions.</div></li><ul><li><div>SELECT location, dept, SUM (salary)</div></li><li><div>FROM employee</div></li><li><div>GROUP BY location, dept;</div></li></ul></ul><li><div>SQL Having</div></li><ul><li><div>Having clause is used to filter data based on the group functions. This is similar to WHERE condition but is used with group functions. Group functions cannot be used in WHERE Clause but can be used in HAVING clause.</div></li><li><div>If you want to select the department that has total salary paid for its employees more than 25000, the sql query would be like;</div></li><ul><li><div>SELECT dept, SUM (salary)</div></li><li><div>FROM employee</div></li><li><div>GROUP BY dept</div></li><li><div>HAVING SUM (salary) &gt; 25000</div></li></ul></ul><li><div>Transactions</div></li><ul><li><div>Commit</div></li><li><div>Rollback</div></li><li><div>Savepoint</div></li><ul><li><div>COMMIT command is used to permanently save any transaction into the database.</div></li></ul></ul></ul><ul><li><div>When we use any DML command like INSERT, UPDATE or DELETE, the changes made by these commands are not permanent, until the current session is closed, the changes made by these commands can be rolled back.</div></li></ul><ul><li><div>To avoid that, we use the COMMIT command to mark the changes as permanent.</div></li></ul><ul><ul><li><div>Following is commit command's syntax,</div></li><ul><li><div>Commit</div></li></ul></ul><li><div>Rollback</div></li><ul><li><div>This command restores the database to last commited state. It is also used with SAVEPOINT command to jump to a savepoint in an ongoing transaction.</div></li></ul></ul><ul><li><div>If we have used the UPDATE command to make some changes into the database, and realise that those changes were not required, then we can use the ROLLBACK command to rollback those changes, if they were not commited using the COMMIT command.</div></li></ul><ul><ul><li><div>Following is rollback command's syntax,</div></li><ul><li><div>ROLLBACK TO savepoint_name;</div></li></ul></ul><li><div>Savepoint</div></li><ul><li><div>SAVEPOINT command is used to temporarily save a transaction so that you can rollback to that point whenever required.</div></li></ul></ul><ul><ul><li><div>Following is savepoint command's syntax,</div></li><ul><li><div>SAVEPOINT savepoint_name;</div></li></ul></ul><li><div>ACID</div></li><ul><li><div>(an acronym for Atomicity, Consistency Isolation, Durability) is a concept that Database Professionals generally look for when evaluating databases and application architectures. For a reliable database all these four attributes should be achieved.</div></li><ul><li><div>Atomicity is an all-or-none proposition.</div></li><ul><li><div>Smallest logical unit that can be run.</div></li><li><div>All or nothing.</div></li><li><div>All operations execute successfully or rollback.</div></li><li><div>If we have bad atomicity, we can lose referential integrity</div></li></ul></ul></ul></ul><ul><li><div>Consistency guarantees that a transaction never leaves your database in a half-finished state.</div></li><li><div>Isolation keeps transactions separated from each other until they’re finished.</div></li><ul><li><div>Concurrent transactions do not affect each other.</div></li><li><div>One transaction must complete before another may execute, to sharing resources.</div></li><li><div>The system state during concurrent transactions is the same as if transactions were sequential.</div></li></ul></ul><ul><ul><li><div>Durability guarantees that the database will keep track of pending changes in such a way that the server can recover from an abnormal termination.</div></li><li><div>If you shoot it, you have a backup.</div></li><li><div>Even in catastrophic failure of a database, the transaction will complete.</div></li><li><div>All commits are final and cannot be rolled back even in system failure.</div></li></ul><li><div>Transaction Phenomenon</div></li><ul><li><div>//Filler</div></li></ul><li><div>Dirty Read</div></li><ul><li><div>A dirty read takes no notice of any lock taken by another process. The read is officially “dirty” when it reads data that is uncommitted. This can become problematic if the uncommitted transaction fails or for some other reason is rolled back.</div></li><li><div>Imagine a scenario in which you are shopping on a website and place an item into your basket and proceed to payment. The site’s checkout process decrements the stock by one and starts to charge your card all in the one transaction. At that time, a second unrelated process starts. The website’s back office stock interface runs and makes a dirty read of all the product inventory levels, reading the reduced value. Unfortunately, there is a problem with your transaction (insufficient funds), and your purchase transaction is rolled back. The website stock level has now reverted to the original level, but the stock interface has just reported a different value.</div></li><li><div>You can run the following example against the AdventureWorks2012 database. Session 1 starts an explicit transaction to update all persons with a last name of “Jones” to have the same first name of “James.” This transaction will be rolled back after five seconds, and a SELECT is run to show the original values (code file Ch6DirtyReads.sql):</div></li></ul><li><div>Non-Repeatable Read</div></li><ul><li><div>A non-repeatable read is one in which data read twice inside the same transaction cannot be guaranteed to contain the same value. Depending on the isolation level, another transaction could have nipped in and updated the value between the two reads.</div></li><li><div>Non-repeatable reads occur because at lower isolation levels reading data only locks the data for the duration of the read, rather than for the duration of the transaction. Sometimes this behavior might be completely desirable. Some applications may want to know the absolute, real-time value, even mid transaction, whereas other types of transactions might need to read the same value multiple times.</div></li><li><div>Consider the following example. In Session 1 the transaction reads the data for the top five people from Person.Person and then waits for five seconds before repeating the step. Execute the code in Session 1 before flipping to a second session and executing the code in Session 2 (code file Ch6NonRepeatableReads.sql):</div></li></ul><li><div>Phanton Read</div></li><ul><li><div>A phantom read occurs when, in the course of a transaction, two identical queries are executed, and the collection of rows returned by the second query is different from the first. Simple examples: User A runs the same query twice</div></li></ul><li><div>Read Uncommited</div></li><ul><li><div>transactions from modifying data read by the current transaction. READ UNCOMMITTED transactions are also not blocked by exclusive locks that would prevent the current transaction from reading rows that have been modified but not committed by other transactions. When this option is set, it is possible to read uncommitted modifications, which are called dirty reads. Values in the data can be changed and rows can appear or disappear in the data set before the end of the transaction. This option has the same effect as setting NOLOCK on all tables in all SELECT statements in a transaction. This is the least restrictive of the isolation levels.</div></li></ul><li><div>Read commited</div></li><ul><li><div>Specifies that statements cannot read data that has been modified but not committed by other transactions. This prevents dirty reads. Data can be changed by other transactions between individual statements within the current transaction, resulting in nonrepeatable reads or phantom data. This option is the SQL Server default.</div></li></ul><li><div>Repeatable Read</div></li><ul><li><div>Specifies that statements cannot read data that has been modified but not yet committed by other transactions and that no other transactions can modify data that has been read by the current transaction until the current transaction completes.</div></li></ul></ul><ul><ul><li><div>Shared locks are placed on all data read by each statement in the transaction and are held until the transaction completes. This prevents other transactions from modifying any rows that have been read by the current transaction. Other transactions can insert new rows that match the search conditions of statements issued by the current transaction. If the current transaction then retries the statement it will retrieve the new rows, which results in phantom reads. Because shared locks are held to the end of a transaction instead of being released at the end of each statement, concurrency is lower than the default READ COMMITTED isolation level. Use this option only when necessary.</div></li></ul><li><div>Serializable</div></li><ul><li><div>Statements cannot read data that has been modified but not yet committed by other transactions.</div></li></ul></ul><ul><li><div>No other transactions can modify data that has been read by the current transaction until the current transaction completes.</div></li></ul><ul><li><div>Other transactions cannot insert new rows with key values that would fall in the range of keys read by any statements in the current transaction until the current transaction completes.</div></li></ul><ul><ul><li><div>Range locks are placed in the range of key values that match the search conditions of each statement executed in a transaction. This blocks other transactions from updating or inserting any rows that would qualify for any of the statements executed by the current transaction. This means that if any of the statements in a transaction are executed a second time, they will read the same set of rows. The range locks are held until the transaction completes. This is the most restrictive of the isolation levels because it locks entire ranges of keys and holds the locks until the transaction completes. Because concurrency is lower, use this option only when necessary. This option has the same effect as setting HOLDLOCK on all tables in all SELECT statements in a transaction.</div></li></ul><li><div>Sequences</div></li><ul><li><div>Stores and tracks a number that can be incremented/decremented.</div></li><li><div>Used for auto-incrementing primary keys</div></li><li><div>Can grab the current or next value (nextVal)</div></li><li><div>Good rule of thumb is to start with value 1001, so admins can use the smaller values for future purposes.</div></li><li><div>You could use a function in the INCREMENT BY statement.</div></li><li><div>Cache - storing values in memory for faster access.</div></li><li><div>START WITH and INCREMENT BY are the ones we’ll be using primarily. Default value for INCREMENT BY is 1.</div></li><li><div>You can run a valid sequence with the command CREATE SEQUENCE [name];</div></li><li><div>Default values will be used.</div></li></ul><li><div>Sub Quries</div></li><ul><li><div>Query nested inside another query</div></li><li><div>Nested in the where clause</div></li><li><div>Narrowing down the result set</div></li><li><div>Correlated</div></li><ul><li><div>A correlated subquery is one way of reading every row in a table and comparing values in each row against related data. It is used whenever a subquery must return a different result or set of results for each candidate row considered by the main query. In other words, you can use a correlated subquery to answer a multipart question whose answer depends on the value in each row processed by the parent statement</div></li><li><div>A correlated subquery is one way of reading every row in a table and comparing values in each row against related data. It is used whenever a subquery must return a different result or set of results for each candidate row considered by the main query. In other words, you can use a correlated subquery to answer a multipart question whose answer depends on the value in each row processed by the parent statementWith a normal nested subquery, the inner SELECT query runs first and executes once, returning values to be used by the main query. A correlated subquery, however, executes once for each candidate row considered by the outer query. In other words, the inner query is driven by the outer query.</div></li><li><div>NOTE : You can also use the ANY and ALL operator in a correlated subquery.</div></li><li><div>Makes reference to the query above it</div></li><ul><li><div>It uses those referneces in its calculation</div></li></ul></ul></ul></ul><ul><ul><li><div>Non-Correlated</div></li><ul><li><div>No reference to the query above it</div></li><li><div>You can both queries independently and they would return a result</div></li></ul></ul><li><div>Triggers</div></li><ul><li><div>Triggers are stored programs, which are automatically executed or fired when some events occur.</div></li><li><div>Benefits of Triggers</div></li><ul><li><div>Triggers can be written for the following purposes −</div></li></ul></ul></ul><ul><ul><li><div>Generating some derived column values automatically</div></li><li><div>Enforcing referential integrity</div></li><li><div>Event logging and storing information on table access</div></li><li><div>Auditing</div></li><li><div>Synchronous replication of tables</div></li><li><div>Imposing security authorizations</div></li><li><div>Preventing invalid transactions</div></li></ul><li><div>CREATE [OR REPLACE ] TRIGGER trigger_name  </div></li><li><div>{BEFORE | AFTER | INSTEAD OF }  </div></li><li><div>{INSERT [OR] | UPDATE [OR] | DELETE}  </div></li><li><div>[OF col_name]  </div></li><li><div>ON table_name  </div></li><li><div>[REFERENCING OLD AS o NEW AS n]  </div></li><li><div>[FOR EACH ROW]  </div></li><li><div>WHEN (condition)   </div></li><li><div>DECLARE</div></li><li><div>   Declaration-statements</div></li><li><div>BEGIN  </div></li><li><div>   Executable-statements</div></li><li><div>EXCEPTION</div></li><li><div>   Exception-handling-statements</div></li><li><div>END;</div></li><li><div>Explained Below</div></li><ul><li><div>CREATE [OR REPLACE] TRIGGER trigger_name − Creates or replaces an existing trigger with the trigger_name.</div></li></ul></ul><ul><li><div>{BEFORE | AFTER | INSTEAD OF} − This specifies when the trigger will be executed. The INSTEAD OF clause is used for creating trigger on a view.</div></li></ul><ul><li><div>{INSERT [OR] | UPDATE [OR] | DELETE} − This specifies the DML operation.</div></li></ul><ul><li><div>[OF col_name] − This specifies the column name that will be updated.</div></li></ul><ul><li><div>[ON table_name] − This specifies the name of the table associated with the trigger.</div></li></ul><ul><li><div>[REFERENCING OLD AS o NEW AS n] − This allows you to refer new and old values for various DML statements, such as INSERT, UPDATE, and DELETE.</div></li></ul><ul><li><div>[FOR EACH ROW] − This specifies a row-level trigger, i.e., the trigger will be executed for each row being affected. Otherwise the trigger will execute just once when the SQL statement is executed, which is called a table level trigger.</div></li></ul><ul><ul><li><div>WHEN (condition) − This provides a condition for rows for which the trigger would fire. This clause is valid only for row-level triggers.</div></li></ul><li><div>Stored procedure</div></li><ul><li><div>The MS SQL Server Stored procedure is used to save time to write code again and again by storing the same in database and also get the required output by passing parameters.</div></li><li><div>Create procedure &lt;procedure_Name&gt;</div><div>As</div><div>Begin</div><div>&lt;SQL Statement&gt;</div><div>End</div><div>Go</div></li><li><div>// Do not have more information on this. Will have to look it up.</div></li></ul></ul><ul><li><div>SQL Index</div></li><ul><li><div>Index in sql is created on existing tables to retrieve the rows quickly.</div></li></ul></ul><ul><li><div>When there are thousands of records in a table, retrieving information will take a long time. Therefore indexes are created on columns which are accessed frequently, so that the information can be retrieved quickly. Indexes can be created on a single column or a group of columns. When a index is created, it first sorts the data and then it assigns a ROWID for each row.</div></li><ul><li><div>CREATE INDEX index_name</div></li><li><div>ON table_name (column_name1,column_name2...);</div></li></ul></ul><div><br/></div><div><br/></div></div></span>
</div></body></html> 